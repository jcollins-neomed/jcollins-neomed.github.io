<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Jason's Lottery Helper Tool</title>
    <!-- Load PapaParse for CSV handling -->
    <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: #f9fafb;
            color: #333;
            margin: 0;
            padding: 20px;
        }
        .container {
            /* max-width: 1400px; */ /* Removed for full-width layout */
            margin: 0 auto;
        }
        .app-title {
            text-align: center;
            font-size: 2rem;
            margin-bottom: 20px;
            color: #2c3e50;
        }
        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            justify-content: center;
            align-items: center;
            margin-bottom: 20px;
            padding: 15px;
            background-color: #fff;
            border-radius: 8px;
            box-shadow: 0 2px 6px rgba(0,0,0,0.05);
        }
        .control-group {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
        }
        #addMessage {
            margin-left: 10px;
            font-size: 0.9em;
            color: #4CAF50;
            font-weight: 500;
        }
        label {
            margin-bottom: 5px;
            font-weight: 600;
            color: #555;
            font-size: 0.9rem;
        }
        .styled-select, .btn-primary, .btn-secondary {
            padding: 8px 12px;
            border-radius: 6px;
            border: 1px solid #ccc;
            font-size: 1rem;
            background-color: #fff;
        }
        .btn-primary, .btn-secondary {
            border: none;
            cursor: pointer;
            transition: background-color 0.2s ease, box-shadow 0.2s ease;
        }
        .btn-secondary {
            background-color: #6c757d;
            color: white;
        }
        .btn-secondary:hover {
            background-color: #5a6268;
        }
        .btn-primary {
            background-color: #007bff;
            color: white;
        }
        .btn-primary:hover {
            background-color: #0069d9;
        }
        .btn-danger {
            background-color: #f44336;
            color: white;
            border: none;
            cursor: pointer;
            font-size: 0.9rem;
            padding: 4px 8px;
            border-radius: 4px;
            transition: background-color 0.2s ease;
        }
        .btn-danger:hover {
            background-color: #d32f2f;
        }
        
        /* Style for small rank-list buttons */
        .btn-rank {
            background-color: #f0f0f0;
            color: #333;
            border: 1px solid #ccc;
            cursor: pointer;
            font-size: 1rem;
            padding: 0px 6px;
            border-radius: 4px;
            margin: 0 2px;
            line-height: 1.2;
        }
        .btn-rank:hover {
            background-color: #e0e0e0;
        }
        .btn-rank:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* --- Star Rating Styles --- */
        .star-rating-container {
            min-width: 140px; /* Give stars room */
            text-align: center;
        }
        .star {
            font-size: 1.75rem; /* Make stars bigger */
            color: #ccc;
            background: none;
            border: none;
            cursor: pointer;
            padding: 0 1px;
            transition: color 0.2s ease, transform 0.1s ease;
            line-height: 1;
        }
        .star:hover {
            color: #f39c12; /* Hover color */
            transform: scale(1.1);
        }
        .star.filled {
            color: #f1c40f; /* Filled color */
        }
        /* Stars in the rank list (display only) */
        .rank-item-rating {
            display: flex;
            gap: 2px;
            font-size: 1.2rem;
            color: #f1c40f;
        }
        .rank-item-rating .star {
            font-size: 1.2rem;
            color: #ccc;
            padding: 0;
            cursor: default;
        }
         .rank-item-rating .star:hover {
            color: #ccc; /* No hover effect */
            transform: none;
        }
         /* Make stars on rank list editable */
         .rank-item-rating.editable .star {
            cursor: pointer;
            padding: 0 1px;
        }
         .rank-item-rating.editable .star:hover {
            color: #f39c12; /* Hover color */
            transform: scale(1.1);
        }
        .rank-item-rating .star.filled {
            color: #f1c40f;
        }
        /* --- End Star Styles --- */

        table {
            border-collapse: collapse;
            margin-top: 1em;
            width: 100%;
            background: white;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 2px 6px rgba(0,0,0,0.1);
        }
        th, td {
            border-bottom: 1px solid #eee;
            padding: 10px 12px;
            text-align: center;
            vertical-align: middle;
        }
        th {
            background: #f3f4f6;
            font-weight: 600;
            color: #374151;
            font-size: 0.85rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        tr:hover {
            background-color: #f9fafb;
        }
        
        .rotation {
            display: inline-block;
            padding: 4px 8px;
            margin-bottom: 4px;
            border-radius: 4px;
            color: #fff;
            font-size: 0.85em;
            font-weight: 500;
        }
        .site {
            font-size: 0.8em;
            color: #555;
            display: block; /* Ensure it wraps */
        }
        .grid-table {
            border-collapse: collapse;
            margin: 20px auto;
            background: white;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 2px 6px rgba(0,0,0,0.1);
        }
        .grid-table th, .grid-table td {
            padding: 6px 8px;
            border-bottom: 1px solid #eee;
            text-align: center;
        }
        #filterGrid strong {
            display: block;
            text-align: center;
            margin-bottom: 10px;
            font-size: 1.1rem;
            color: #2c3e50;
        }

        /* --- New Styles for Rank List Section --- */
        .rank-list-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            flex-wrap: wrap;
            gap: 10px;
        }
        .rank-list-header .rank-message {
            margin-left: 10px;
            font-size: 0.9em;
        }
        .rank-list-ul { /* Changed from ol to ul */
            list-style-type: none; /* No numbers */
            padding-left: 0;
            background: #fff;
            border-radius: 8px;
            box-shadow: 0 2px 6px rgba(0,0,0,0.1);
            padding: 10px;
            margin: 0;
        }
        .rank-list-ul li {
            padding: 15px;
            border-bottom: 1px solid #eee;
            display: block; 
            font-size: 1.1rem;
        }
        .rank-list-ul li:last-child {
            border-bottom: none;
        }
        .rank-list-ul li .rank-item-name {
            font-weight: 600;
            color: #333;
        }
        .rank-list-ul li .rank-item-city {
            font-size: 0.9rem;
            color: #777;
            margin-left: 8px;
        }
        .rank-list-ul li .rank-controls {
            display: flex;
            align-items: center;
            gap: 15px; /* More space for stars */
        }
        .rank-item-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px; 
            flex-wrap: wrap;
            gap: 10px;
        }
        .rank-item-details {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            padding: 8px;
            background-color: #f7f7f7;
            border-radius: 4px;
            border: 1px solid #f0f0f0;
        }
        .rank-block {
            flex: 1; 
            min-width: 80px; 
            padding: 6px;
            border: 1px solid #e5e5e5;
            border-radius: 4px;
            background: #fff;
            text-align: center;
            font-size: 0.8rem; 
        }
        .rank-block-number {
            font-weight: bold;
            font-size: 0.9em;
            color: #333;
            margin-bottom: 4px;
        }
        .rank-block .rotation {
            font-size: 0.9em; 
            padding: 2px 4px;
        }
        .rank-block .site {
            font-size: 0.85em;
            margin-top: 4px; 
        }
        
        /* Header for rating groups on rank list */
        .rating-group-header {
            font-size: 1.5rem;
            font-weight: 600;
            color: #2c3e50;
            margin-top: 25px;
            margin-bottom: 10px;
            padding-bottom: 5px;
            border-bottom: 2px solid #007bff;
        }
        /* Remove top margin from the very first header */
        h3.rating-group-header:first-of-type {
            margin-top: 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1 class="app-title">Jason's Lottery Helper Tool</h1>

        <section class="controls">
            <div class="control-group">
                <label for="dropdown">City:</label>
                <select id="dropdown" class="styled-select">
                    <option value="">--All Cities--</option>
                    <option value="Akron">Akron</option>
                    <option value="Eastern Cleveland">Eastern Cleveland</option>
                    <option value="Western Cleveland">Western Cleveland</option>
                    <option value="Youngstown">Youngstown</option>
                    <option value="Columbus">Columbus</option>
                    <option value="Rootstown">Rootstown</option>
                    <option value="Canton">Canton</option>
                </select>
            </div>
        
            <div class="control-group">
                <label for="mode">Filter Mode:</label>
                <select id="mode" class="styled-select">
                    <option value="city">City Only</option>
                    <option value="rotation">Rotation Only</option>
                    <option value="and">City AND Rotation</option>
                </select>
            </div>
        
            <button id="searchBtn" class="btn-primary">Search</button>
            <button id="viewRankListBtn" class="btn-secondary">
                View Rank List (<span id="rankCount">0</span>)
            </button>
            <span id="addMessage"></span> <!-- For "Rating saved!" messages -->
        </section>

        <!-- This 'main' tag now wraps the original search/filter/results sections -->
        <main id="searchSection">
            <section id="filterGrid"></section>
            <section id="result"></section>
        </main>

        <!-- New, hidden section for the Rank List -->
        <section id="rankListSection" style="display: none;">
            <input type="file" id="uploadCSVInput" accept=".csv" style="display: none;"> <!-- Hidden file input -->
            <div class="rank-list-header">
                <h2 class="app-title" style="margin: 0;">My Rank List</h2>
                <div>
                    <button id="backToSearchBtn" class="btn-secondary">← Back to Search</button>
                    <button id="uploadCSVBtn" class="btn-secondary">Upload CSV</button> <!-- Upload button -->
                    <button id="downloadCSVBtn" class="btn-primary">Download as CSV</button>
                    <span id="rankListMessage" class="rank-message"></span>
                </div>
            </div>
            <p id="rankListEmpty" style="text-align: center; display: none; padding: 20px;">Your rank list is empty. Go back to search to add ratings.</p>
            <!-- Changed to <ul> -->
            <ul id="rankListItems" class="rank-list-ul"></ul>
        </section>
    </div>

    <script>
    document.addEventListener('DOMContentLoaded', () => {
        const dropdown = document.getElementById('dropdown');
        const modeSelect = document.getElementById('mode');
        const searchBtn = document.getElementById('searchBtn');
        const resultDiv = document.getElementById('result');
        const filterGridDiv = document.getElementById('filterGrid');

        // New Rank List elements
        const searchSection = document.getElementById('searchSection');
        const rankListSection = document.getElementById('rankListSection');
        const viewRankListBtn = document.getElementById('viewRankListBtn');
        const backToSearchBtn = document.getElementById('backToSearchBtn');
        const downloadCSVBtn = document.getElementById('downloadCSVBtn');
        const uploadCSVBtn = document.getElementById('uploadCSVBtn'); 
        const uploadCSVInput = document.getElementById('uploadCSVInput');
        const rankListItems = document.getElementById('rankListItems');
        const rankCountSpan = document.getElementById('rankCount');
        const addMessageSpan = document.getElementById('addMessage');
        const rankListEmptyP = document.getElementById('rankListEmpty');
        const rankListMessageSpan = document.getElementById('rankListMessage');

        // Global state for rank list
        // Now an array of { schedule: Object, rating: Number, rankOrder: Number }
        let rankList = []; 
        let allSchedules = []; // Store all schedules from the main CSV
        // To be populated by CSV parse
        let idKey, cityKey;

        const numBlocks = 9;
        const specialties = [
            'Surgery','Obstetric/Gynecology','Family Medicine',
            'Psychiatry','Internal Medicine','Emergency Medicine',
            'Pediatrics','Elective'
        ];

        // Build grid
        let gridHTML = '<table class="grid-table"><thead><tr><th>Rotation</th>';
        for (let i = 1; i <= numBlocks; i++) gridHTML += `<th>${i}</th>`;
        gridHTML += '</tr></thead><tbody>';
        specialties.forEach(spec => {
            gridHTML += `<tr><td>${spec}</td>`;
            for (let i = 1; i <= numBlocks; i++) {
            gridHTML += `<td><input type="checkbox" data-rotation="${spec}" data-block="${i}" checked></td>`;
            }
            gridHTML += '</tr>';
        });
        gridHTML += '</tbody></table>';
        filterGridDiv.innerHTML = `<strong>Allowed Rotations (uncheck to exclude):</strong>${gridHTML}`;

        const specialtyColors = {
            'Surgery':'#9C27B0','Obstetric/Gynecology':'#E91E63',
            'Family Medicine':'#4CAF50','Psychiatry':'#795548',
            'Internal Medicine':'#2196F3','Emergency Medicine':'#3F51B5',
            'Pediatrics':'#FF9800','Elective':'#9E9E9E'
        };
        const colorFor = s => specialtyColors[s] || '#607D8B';

        async function loadMasterSchedule() {
            if (allSchedules.length > 0) return true; // Already loaded

            try {
                // IMPORTANT: Make sure 'schedules.csv' is in the same directory
                // or update this path.
                const resp = await fetch('schedules.csv'); 
                if (!resp.ok) {
                    throw new Error(`Failed to fetch schedules.csv: ${resp.statusText}`);
                }
                const text = await resp.text();
                const parsed = Papa.parse(text,{
                    header:true, skipEmptyLines:true,
                    transformHeader:h=>h.replace(/^\uFEFF/,'').trim()
                });

                if(!parsed.data.length) {
                    console.error("Master schedule CSV empty or unreadable");
                    resultDiv.textContent = 'Error: Master schedule file is empty.';
                    return false;
                }
                
                // Store all data
                allSchedules = parsed.data;

                // Detect actual city key dynamically
                const headers = Object.keys(allSchedules[0]);
                // Set global keys if not already set
                if (!cityKey) {
                    cityKey = headers.find(k=>k.trim().toLowerCase().includes('city')) || 'Dominant City';
                }
                if (!idKey) {
                    idKey = headers.find(k=>k.trim().toLowerCase().includes('id')) || headers[0];
                }
                console.log(`Using ID Key: '${idKey}', City Key: '${cityKey}'`);
                return true; // Success

            } catch (e) {
                console.error("Error loading master schedule:", e);
                resultDiv.textContent = 'Error: Could not load master schedule file (schedules.csv). Make sure it exists.';
                return false; // Failure
            }
        }


        // --- View Toggling ---
        function showSection(sectionToShow) {
            if (sectionToShow === 'rank') {
                searchSection.style.display = 'none';
                rankListSection.style.display = 'block';
                renderRankList(); // Re-render the list every time we show it
            } else {
                searchSection.style.display = 'block';
                rankListSection.style.display = 'none';
            }
        }

        viewRankListBtn.addEventListener('click', () => showSection('rank'));
        backToSearchBtn.addEventListener('click', () => showSection('search'));

        // --- Rank List Logic ---
        function renderRankList() {
            rankListItems.innerHTML = ''; // Clear existing list
            rankCountSpan.textContent = rankList.length;

            if (rankList.length === 0) {
                rankListEmptyP.style.display = 'block';
                rankListItems.style.display = 'none';
                return;
            }

            rankListEmptyP.style.display = 'none';
            rankListItems.style.display = 'block';

            // --- SORT BY RATING (primary) AND RANK ORDER (secondary) ---
            rankList.sort((a, b) => b.rating - a.rating || a.rankOrder - b.rankOrder);
            
            let currentRatingGroup = -1; // For grouping headers

            rankList.forEach((item, index) => {
                // item is { schedule: {...}, rating: X, rankOrder: Y }
                const schedule = item.schedule;
                const rating = item.rating;

                // --- Add rating group header if new ---
                if (rating !== currentRatingGroup) {
                    const header = document.createElement('h3');
                    header.className = 'rating-group-header';
                    header.textContent = `${rating} Star${rating > 1 ? 's' : ''}`;
                    rankListItems.appendChild(header);
                    currentRatingGroup = rating;
                }

                const li = document.createElement('li');
                
                const id = idKey ? schedule[idKey] : 'Unknown ID';
                const city = cityKey ? schedule[cityKey] : 'Unknown City';

                // --- Build Star Display (now editable) ---
                let starsDisplayHTML = `<div class="rank-item-rating editable">`;
                for (let i = 1; i <= 5; i++) {
                    starsDisplayHTML += `<button 
                                            class="star ${i <= rating ? 'filled' : ''}" 
                                            data-value="${i}" 
                                            data-id="${id}" 
                                            aria-label="${i} star"
                                          >&#9733;</button>`;
                }
                starsDisplayHTML += '</div>';

                // --- Determine disabled state for arrows ---
                // Disabled if first item OR if item above has a different rating
                const upDisabled = (index === 0 || rankList[index - 1].rating !== rating);
                // Disabled if last item OR if item below has a different rating
                const downDisabled = (index === rankList.length - 1 || rankList[index + 1].rating !== rating);

                // 1. Create the header (ID, City, Stars, Controls)
                let headerHTML = `
                <div class="rank-item-header">
                    <div>
                        <span class="rank-item-name">${id}</span>
                        <span class="rank-item-city">${city}</span>
                    </div>
                    <div class="rank-controls">
                        <button class="btn-rank" data-index="${index}" aria-label="Move up" ${upDisabled ? 'disabled' : ''}>↑</button>
                        <button class="btn-rank" data-index="${index}" aria-label="Move down" ${downDisabled ? 'disabled' : ''}>↓</button>
                        ${starsDisplayHTML}
                        <button class="btn-danger" data-id="${id}" aria-label="Remove">×</button>
                    </div>
                </div>
                `;

                // 2. Create the details (all the blocks)
                let detailsHTML = '<div class="rank-item-details">';
                for (let i = 1; i <= numBlocks; i++) {
                    const rotation = (schedule[`Block ${i} Rotation`] || '').trim();
                    const site = (schedule[`Block ${i} Site`] || '').trim();
                    
                    detailsHTML += `
                    <div class="rank-block">
                        <div class="rank-block-number">Block ${i}</div>
                        <span class="rotation" style="background-color:${colorFor(rotation)}">${rotation || 'N/A'}</span>
                        <div class="site">${site || '-'}</div>
                    </div>
                    `;
                }
                detailsHTML += '</div>';

                // 3. Set the combined HTML
                li.innerHTML = headerHTML + detailsHTML;
                rankListItems.appendChild(li);
            });
        }

        // Handle clicks for remove button, editable stars, and up/down arrows
        rankListItems.addEventListener('click', (e) => {
            const removeButton = e.target.closest('button.btn-danger');
            const starButton = e.target.closest('button.star');
            const upButton = e.target.closest('.btn-rank[aria-label="Move up"]');
            const downButton = e.target.closest('.btn-rank[aria-label="Move down"]');

            if (removeButton) {
                const schedId = removeButton.dataset.id;
                const index = rankList.findIndex(item => item.schedule[idKey] === schedId);
                
                if (index > -1) {
                    rankList.splice(index, 1);
                }
                
                renderRankList(); 
                searchCSV(false); // Update search page stars
                return; // Stop execution
            }

            if (starButton) {
                const rating = parseInt(starButton.dataset.value, 10);
                const schedId = starButton.dataset.id;
                const index = rankList.findIndex(item => item.schedule[idKey] === schedId);

                if (index === -1) return; // Should not happen

                let message = '';
                if (rankList[index].rating === rating) { // Clicking same star
                    rankList.splice(index, 1); // Remove it (un-rate)
                    message = 'Rating removed!';
                } else {
                    rankList[index].rating = rating; // Update rating
                    // Leave rankOrder alone, sorting will handle it
                    message = `Rating updated to ${rating}!`;
                }

                // Show message on rank list page
                rankListMessageSpan.textContent = message;
                rankListMessageSpan.style.color = '#4CAF50';
                setTimeout(() => rankListMessageSpan.textContent = '', 2000);

                renderRankList(); // Re-render and re-sort
                searchCSV(false); // Update search page stars
            }
            
            if (upButton) {
                const index = parseInt(upButton.dataset.index, 10);
                if (index === 0) return; // Should be disabled, but check anyway

                const itemA = rankList[index];
                const itemB = rankList[index - 1];

                // Only swap if they have the same rating
                if (itemA && itemB && itemA.rating === itemB.rating) {
                    // Swap their rankOrder values
                    [itemA.rankOrder, itemB.rankOrder] = [itemB.rankOrder, itemA.rankOrder];
                    renderRankList(); // Re-render to show new order
                }
            }
            
            if (downButton) {
                const index = parseInt(downButton.dataset.index, 10);
                if (index === rankList.length - 1) return; // Should be disabled

                const itemA = rankList[index];
                const itemB = rankList[index + 1];

                // Only swap if they have the same rating
                if (itemA && itemB && itemA.rating === itemB.rating) {
                    // Swap their rankOrder values
                    [itemA.rankOrder, itemB.rankOrder] = [itemB.rankOrder, itemA.rankOrder];
                    renderRankList(); // Re-render to show new order
                }
            }
        });

        // Handle adding/updating rating from the results table (Event Delegation)
        resultDiv.addEventListener('click', (e) => {
            const target = e.target.closest('.star');
            if (!target) return;

            const rating = parseInt(target.dataset.value, 10);
            const schedId = target.dataset.id;
            
            // Find the full schedule data.
            const rowDataString = target.closest('.star-rating-container').dataset.row;
            let scheduleData;
            try {
                scheduleData = JSON.parse(rowDataString.replace(/&apos;/g, "'"));
            } catch(err) {
                console.error("Failed to parse row data for rating:", err);
                return;
            }

            const index = rankList.findIndex(item => item.schedule[idKey] === schedId);
            let newRating = 0;

            if (index > -1) { // Item already in list
                if (rankList[index].rating === rating) { // Clicking same star
                    rankList.splice(index, 1); // Remove it (un-rate)
                    newRating = 0;
                } else {
                    rankList[index].rating = rating; // Update rating
                    // Leave rankOrder unchanged
                    newRating = rating;
                }
            } else { // New item
                // Add new item with a high rankOrder so it goes to the end of its group
                rankList.push({ schedule: scheduleData, rating: rating, rankOrder: rankList.length });
                newRating = rating;
            }

            // Update UI
            rankCountSpan.textContent = rankList.length;
            addMessageSpan.textContent = newRating > 0 ? `Rating ${newRating} saved!` : 'Rating removed!';
            setTimeout(() => addMessageSpan.textContent = '', 2000);

            // Update stars in just this row
            const starContainer = target.parentElement;
            starContainer.querySelectorAll('.star').forEach(star => {
                const starValue = parseInt(star.dataset.value, 10);
                if (starValue <= newRating) {
                    star.classList.add('filled');
                } else {
                    star.classList.remove('filled');
                }
            });
        });


        // Handle Upload CSV Button Click
        uploadCSVBtn.addEventListener('click', () => {
            uploadCSVInput.click(); // Trigger hidden file input
        });

        // Handle File Upload Event
        uploadCSVInput.addEventListener('change', async (event) => { // Made async
            const file = event.target.files[0];
            if (!file) {
                return;
            }

            // Check if main data is loaded, if not, load it
            if (allSchedules.length === 0) {
                rankListMessageSpan.textContent = 'Loading master schedule...';
                rankListMessageSpan.style.color = '#555'; // Neutral color
                
                const success = await loadMasterSchedule();
                
                if (!success) {
                    rankListMessageSpan.textContent = 'Error loading master schedule. Cannot upload.';
                    rankListMessageSpan.style.color = '#f44336';
                    setTimeout(() => {
                        rankListMessageSpan.textContent = '';
                        rankListMessageSpan.style.color = '#4CAF50';
                    }, 3000);
                    event.target.value = null; // Clear file input
                    return;
                }
            }

            // Parse the uploaded CSV
            Papa.parse(file, {
                skipEmptyLines: true,
                complete: (result) => {
                    try {
                        const allSchedulesMap = new Map();
                        allSchedules.forEach(schedule => allSchedulesMap.set(String(schedule[idKey]).trim(), schedule));

                        let dataToProcess = result.data;
                        if (dataToProcess.length === 0) throw new Error("Uploaded file is empty.");
                        
                        // Check for and remove header row
                        const header = dataToProcess[0].map(h => String(h).toLowerCase().trim());
                        const idColIndex = header.findIndex(h => h.includes('id'));
                        const ratingColIndex = header.findIndex(h => h.includes('rating') || h.includes('star'));

                        // Try to find old 'Rank' column for compatibility
                        const rankColIndex = header.findIndex(h => h === 'rank');

                        if (idColIndex === -1) {
                             throw new Error('Uploaded CSV must have a "Schedule ID" column.');
                        }
                        // Handle files with ratings or just old rank order
                        const hasRating = ratingColIndex > -1;
                        const hasRank = rankColIndex > -1;

                        if (!hasRating && !hasRank) {
                            throw new Error('Uploaded CSV must have "Rating" or "Rank" column.');
                        }
                        
                        dataToProcess = dataToProcess.slice(1); // Remove header

                        const newRankList = [];
                        const foundIDs = new Set();
                        let notFoundCount = 0;
                        let invalidRatingCount = 0;

                        dataToProcess.forEach((row, fileIndex) => {
                            const id = row[idColIndex] ? String(row[idColIndex]).trim() : null;
                            
                            let rating = 0;
                            let rankOrder = fileIndex; // Default rank order

                            if (hasRating) {
                                rating = parseInt(row[ratingColIndex], 10);
                            }
                            if (hasRank) {
                                // If no rating, use rank as a placeholder "rating" (e.g., 1, 2, 3...)
                                // We'll just assign a 1-star rating and use file order
                                if (!hasRating) {
                                    rating = 1; // Assign a default 1-star
                                }
                                rankOrder = parseInt(row[rankColIndex], 10);
                                if (isNaN(rankOrder)) rankOrder = fileIndex;
                            }


                            if (!id || (hasRating && (isNaN(rating) || rating < 1 || rating > 5))) {
                                if (id) invalidRatingCount++; // Count if ID was present but rating wasn't
                                return; // Skip invalid row
                            }
                            
                            if (allSchedulesMap.has(id) && !foundIDs.has(id)) {
                                newRankList.push({ 
                                    schedule: allSchedulesMap.get(id), 
                                    rating: rating || 1, // Default to 1 star if 0
                                    rankOrder: rankOrder
                                });
                                foundIDs.add(id);
                            } else if (!allSchedulesMap.has(id)) {
                                notFoundCount++;
                            }
                        });

                        rankList = newRankList;
                        renderRankList(); // Re-render the list

                        // Show success/status message
                        let message = `Uploaded ${newRankList.length} items.`;
                        if (notFoundCount > 0) message += ` (${notFoundCount} IDs not found.)`;
                        if (invalidRatingCount > 0) message += ` (${invalidRatingCount} invalid ratings.)`;
                        
                        rankListMessageSpan.textContent = message;
                        rankListMessageSpan.style.color = '#4CAF50';
                        setTimeout(() => rankListMessageSpan.textContent = '', 4000);

                    } catch (err) {
                        console.error("Error processing uploaded CSV:", err);
                        rankListMessageSpan.textContent = err.message || 'Error processing file.';
                        rankListMessageSpan.style.color = '#f44336';
                        setTimeout(() => {
                            rankListMessageSpan.textContent = '';
                            rankListMessageSpan.style.color = '#4CAF50';
                        }, 3000);
                    } finally {
                        event.target.value = null; // Clear file input
                    }
                },
                error: (err) => {
                    console.error("PapaParse error:", err);
                    rankListMessageSpan.textContent = 'Failed to read file.';
                    rankListMessageSpan.style.color = '#f44336';
                    setTimeout(() => {
                        rankListMessageSpan.textContent = '';
                        rankListMessageSpan.style.color = '#4CAF50';
                    }, 3000);
                    event.target.value = null; // Clear file input
                }
            });
        });


        // Handle Download CSV
        downloadCSVBtn.addEventListener('click', () => {
            if (rankList.length === 0) {
                rankListMessageSpan.textContent = 'List is empty.';
                rankListMessageSpan.style.color = '#f44336'; // Make it red
                setTimeout(() => {
                    rankListMessageSpan.textContent = '';
                    rankListMessageSpan.style.color = '#4CAF50'; // Reset color
                }, 3000);
                return;
            }

            // Sort by rating (descending) and then by custom rankOrder (ascending)
            rankList.sort((a, b) => b.rating - a.rating || a.rankOrder - b.rankOrder);

            // Modified CSV content: Schedule ID and Rating
            let csvContent = "Schedule ID,Rating\n";
            rankList.forEach((item) => {
                const id = (idKey && item.schedule[idKey]) ? item.schedule[idKey] : '';
                const rating = item.rating;
                csvContent += `"${id.replace(/"/g, '""')}",${rating}\n`;
            });

            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement("a");
            const url = URL.createObjectURL(blob);
            link.setAttribute("href", url);
            link.setAttribute("download", "my_schedule_ratings.csv");
            link.style.visibility = 'hidden';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        });


        async function searchCSV(doLoad = true) {
            const choice = dropdown.value.trim();
            const mode = modeSelect.value;

            // collect unchecked
            const excluded = {};
            filterGridDiv.querySelectorAll('input[type="checkbox"]:not(:checked)').forEach(cb=>{
                const rot = cb.dataset.rotation, blk = cb.dataset.block;
                if(!excluded[blk]) excluded[blk]=new Set(); excluded[blk].add(rot);
            });
            const rotationFilterActive = Object.keys(excluded).length>0;

            try {
                // Ensure master schedule is loaded
                if (doLoad && allSchedules.length === 0) {
                    addMessageSpan.textContent = 'Loading master schedule...';
                    addMessageSpan.style.color = '#555';
                    const success = await loadMasterSchedule();
                    addMessageSpan.textContent = ''; // Clear message
                    if (!success) {
                        resultDiv.textContent='Error reading CSV file.';
                        return;
                    }
                } else if (allSchedules.length === 0) {
                    // This can happen if searchCSV(false) is called before load
                    console.log("Master schedule not loaded, skipping render.");
                    return;
                }
                
                // Master schedule is loaded, allSchedules, idKey, and cityKey are set.
                // Now, just do the filtering and rendering.

                const filtered = allSchedules.filter(r=>{
                    // Allow empty city choice to show all
                    const cityMatch = !choice || (r[cityKey]||'').trim()===choice;
                    let rotationAllowed=true;
                    if(rotationFilterActive){
                        for(let i=1;i<=numBlocks;i++){
                        const rotation=(r[`Block ${i} Rotation`]||'').trim();
                        if(excluded[i]&&excluded[i].has(rotation)){ rotationAllowed=false; break;}
                        }
                    }
                    switch(mode){
                        case 'city': return cityMatch;
                        case 'rotation': return rotationAllowed;
                        case 'and': return cityMatch && rotationAllowed;
                        default: return true;
                    }
                });

                if(!filtered.length){ resultDiv.textContent='No matches found.'; return;}

                const head = Array.from({length:numBlocks},(_,i)=>`<th>Block ${i+1}</th>`).join('');
                // Modified header to include 'Rating' and 'Schedule'
                let html=`<table><thead><tr><th>Rating</th><th>Schedule</th>${head}</tr></thead><tbody>`;
                
                filtered.forEach(r=>{
                    const sched=(r[idKey]||'').toString().trim();
                    // Check if this item is in the rank list to set button state
                    const currentRating = rankList.find(item => item.schedule[idKey] === sched)?.rating || 0;

                    const cells=[];
                    for(let i=1;i<=numBlocks;i++){
                        const rotation=(r[`Block ${i} Rotation`]||'').trim();
                        const site=(r[`Block ${i} Site`] ||'').trim();
                        cells.push(
                        `<td>
                            <span class="rotation" style="background-color:${colorFor(rotation)}">${rotation || 'N/A'}</span>
                            <div class="site">${site || '-'}</div>
                            </td>`
                        );
                    }
                    
                    // Add the star rating column
                    const rowDataString = JSON.stringify(r).replace(/'/g, "&apos;");
                    let starsHTML = `<td class="star-rating-container" data-row='${rowDataString}'>`;
                    for (let i = 1; i <= 5; i++) {
                        starsHTML += `<button 
                                        class="star ${i <= currentRating ? 'filled' : ''}" 
                                        data-value="${i}" 
                                        data-id="${sched}" 
                                        aria-label="${i} star"
                                      >&#9733;</button>`;
                    }
                    starsHTML += `</td>`;

                    html+=`<tr>${starsHTML}<td>${sched}</td>${cells.join('')}</tr>`;
                });
                html+='</tbody></table>';
                resultDiv.innerHTML=`<strong>Results: (${filtered.length})</strong><br>${html}`;
            } catch(e){
                console.error(e);
                resultDiv.textContent='Error reading CSV file.';
            }
        }

        searchBtn.addEventListener('click', () => searchCSV(true));

        // Initial load
        loadMasterSchedule();
    });
    </script>
</body>
</html>

